import { useState, useEffect, useCallback, useMemo } from 'react'
import { useNavigate } from 'react-router-dom'
import { toast } from 'react-toastify'
// Asegurar que todas las importaciones usen el alias @ para resolver correctamente en Docker
import axiosInstance from '@/components/axiosConfig'
import { useAuth } from '@/hooks/useAuth'
import * as socketService from '@/services/socketService'
// Importar tiendas Zustand
import {
  useUiStore,
  useUsersStore,
  useReservationsStore,
  useFinancesStore,
  usePackagesStore,
  useCategoriesStore,
  useThemesStore,
  useExtrasStore,
  useFoodOptionsStore,
  useMamparasStore,
  usePaymentsStore
} from '@/store'
import ScreenSizeAlert from './dashboard-components/ScreenSizeAlert.jsx'
import UserSummary from './user-service/UserSummary.jsx'
import ReservationSummary from './reservation-service/ReservationSummary.jsx'
import FinancialSummary from './finance-service/FinancialSummary.jsx'
import TabNavigation from './dashboard-components/TabNavigation.jsx'
import UserTable from './user-service/UserTable.jsx'
import ReservationTable from './reservation-service/ReservationTable.jsx'
import FinanceTable from './finance-service/FinanceTable.jsx'
import PackageTable from './catalog-service/paquete-service/PackageTable.jsx'
import MonthSelector from './dashboard-components/MonthSelector.jsx'
import ReservationModal from './reservation-service/ReservationModal.jsx'
import ItemModal from './dashboard-components/ItemModal.jsx'
import FinanceDetailModal from './finance-service/FinanceDetailModal.jsx'
import UserForm from './user-service/UserForm.jsx'
import ReservationForm from './reservation-service/ReservationForm.jsx'
import FinanceForm from './finance-service/FinanceForm.jsx'
import PackageForm from './catalog-service/paquete-service/PackageForm.jsx'
import UserModal from './user-service/UserModal.jsx'
import ExtraForm from './catalog-service/extra-service/ExtraForm.jsx'
import ExtraTable from './catalog-service/extra-service/ExtraTable.jsx'
import OpcionAlimentoForm from './catalog-service/alimento-service/OpcionAlimentoForm.jsx'
import OpcionAlimentoTable from './catalog-service/alimento-service/OpcionAlimentoTable.jsx'
import TematicaForm from './catalog-service/tematica-service/TematicaForm.jsx'
import TematicaTable from './catalog-service/tematica-service/TematicaTable.jsx'
import Swal from 'sweetalert2'
import MonthlyReportModal from './finance-service/MonthlyReportModal.jsx'
import MamparaTable from './catalog-service/mampara-service/MamparaTable.jsx'
import 'react-big-calendar/lib/css/react-big-calendar.css'
import ReservationCalendar from './dashboard-components/ReservationCalendar.jsx'
import MamparaForm from './catalog-service/mampara-service/MamparaForm.jsx'
import PaymentTable from './payment-service/PaymentTable.jsx'
import PaymentForm from './payment-service/PaymentForm.jsx'
import PaymentModal from './payment-service/PaymentModal.jsx'
import PaymentDetails from './payment-service/PaymentDetails.jsx'
import AuditHistory from './auditory-service/AuditHistory.jsx'
import ArchivedTable from './auditory-service/ArchivedTable.jsx'
import GaleriaManagement from './gallery-service/GaleriaManagement.jsx'

const Dashboard = () => {
  const { user: currentUser } = useAuth();
  const navigate = useNavigate()
  
  // Estados de UI desde Zustand
  const { 
    activeTab, setActiveTab,
    isModalOpen, setIsModalOpen,
    isReservationModalOpen, setIsReservationModalOpen,
    isReportModalOpen, setIsReportModalOpen,
    isPaymentModalOpen, setIsPaymentModalOpen,
    isUserModalOpen, setIsUserModalOpen,
    loading, setLoading,
    isSmallScreen, setIsSmallScreen,
    showAlert, setShowAlert,
    userSearch, setUserSearch,
    reservationSearch, setReservationSearch,
    archivedSearch, setArchivedSearch,
    selectedMonth, setSelectedMonth,
    selectedYear, setSelectedYear,
    paymentModalMode, setPaymentModalMode,
    generatedPassword, generateRandomPassword
  } = useUiStore();

  // Estados de entidades (todavía mantenemos el estado local por ahora)
  const [users, setUsers] = useState([])
  const [reservations, setReservations] = useState([])
  const [finances, setFinances] = useState([])
  const [packages, setPackages] = useState([])
  const [categories, setCategories] = useState([])
  const [extras, setExtras] = useState([])
  const [tematicas, setTematicas] = useState([])
  const [archivedItems, setArchivedItems] = useState([]);
  const [editingItem, setEditingItem] = useState(null)
  const [selectedReservation, setSelectedReservation] = useState(null)
  const [selectedFinance, setSelectedFinance] = useState(null)
  const [mamparas, setMamparas] = useState([])
  const [foodOptions, setFoodOptions] = useState([])
  const [payments, setPayments] = useState([])
  const [selectedPayment, setSelectedPayment] = useState(null)
  const [selectedUser, setSelectedUser] = useState(null)

  const handleViewUser = useCallback(user => {
    setSelectedUser(user)
    setIsUserModalOpen(true)
  }, [])

  const generateMonthlyReport = () => {
    setIsReportModalOpen(true)
  }

  const handleSelectReservation = reservation => {
    setSelectedReservation(reservation)
  }

  const handleCloseReservationModal = () => {
    setSelectedReservation(null)
  }

  // Obtener las funciones fetch de las tiendas
  const { fetchUsers: fetchUsersZustand } = useUsersStore();
  const { fetchReservations: fetchReservationsZustand, initSocketListeners } = useReservationsStore();
  const { fetchFinances: fetchFinancesZustand } = useFinancesStore();
  const { fetchPackages: fetchPackagesZustand } = usePackagesStore();
  const { fetchCategories: fetchCategoriesZustand } = useCategoriesStore();
  const { fetchExtras: fetchExtrasZustand } = useExtrasStore();
  const { fetchFoodOptions: fetchFoodOptionsZustand } = useFoodOptionsStore();
  const { fetchThemes: fetchThemesZustand } = useThemesStore();
  const { fetchMamparas: fetchMamparasZustand } = useMamparasStore();
  const { fetchPayments: fetchPaymentsZustand } = usePaymentsStore();

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      // Usar Promise.allSettled para manejar errores individuales sin detener todo el proceso
      const results = await Promise.allSettled([
        fetchUsersZustand().then(data => setUsers(data)),
        fetchReservationsZustand().then(data => setReservations(data)),
        fetchFinancesZustand().then(data => setFinances(data)),
        fetchPackagesZustand().then(data => setPackages(data)),
        fetchCategoriesZustand().then(data => setCategories(data)),
        fetchExtrasZustand().then(data => setExtras(data)),
        fetchFoodOptionsZustand().then(data => setFoodOptions(data)),
        fetchThemesZustand().then(data => setTematicas(data)),
        fetchMamparasZustand().then(data => setMamparas(data)),
        fetchPaymentsZustand().then(data => setPayments(data)),
        // Obtener elementos archivados - todavía usando axios ya que no tenemos tiendas para estos
        axiosInstance.get('/api/reservas/archived'),
        axiosInstance.get('/api/pagos/archived'),
        axiosInstance.get('/api/finanzas/archived')
      ]);

      // Manejar elementos archivados
      const archivedData = [];
      if (results[10].status === 'fulfilled') {
        archivedData.push(...results[10].value.data.map(item => ({ ...item, type: 'reservas' })));
      }
      if (results[11].status === 'fulfilled') {
        archivedData.push(...results[11].value.data.map(item => ({ ...item, type: 'pagos' })));
      }
      if (results[12].status === 'fulfilled') {
        archivedData.push(...results[12].value.data.map(item => ({ ...item, type: 'finanzas' })));
      }
      setArchivedItems(archivedData);

      // Reportar errores
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          console.error(`Error en la solicitud ${index}:`, result.reason);
          toast.error(`Error al cargar los datos de la solicitud ${index + 1}`);
        }
      });
    } catch (error) {
      console.error('Error al cargar los datos:', error);
      toast.error('Error al cargar los datos');
    } finally {
      setLoading(false);
    }
  }, [
    fetchUsersZustand, fetchReservationsZustand, fetchFinancesZustand, 
    fetchPackagesZustand, fetchCategoriesZustand, fetchExtrasZustand, 
    fetchFoodOptionsZustand, fetchThemesZustand, fetchMamparasZustand, 
    fetchPaymentsZustand, setLoading
  ]);

  useEffect(() => {
    // Inicializar datos y configurar Socket.IO
    fetchData().then(() => {
      // Usar la función initSocketListeners de reservationsStore para centralizar la lógica de sockets
      // Esta función se encarga de inicializar Socket.IO y configurar todos los listeners
      // También actualiza automáticamente el estado global de reservations en la tienda
      initSocketListeners({
        onReservaCreada: (nuevaReserva) => {
          console.log('Reserva creada recibida vía Socket.IO:', nuevaReserva);
          toast.success(`Nueva reserva #${nuevaReserva.id} creada`);
        },
        onReservaActualizada: (reservaActualizada) => {
          console.log('Reserva actualizada recibida vía Socket.IO:', reservaActualizada);
        },
        onReservaEliminada: (data) => {
          console.log('Reserva eliminada recibida vía Socket.IO:', data);
        },
        onFechasBloqueadas: (data) => {
          console.log('Fechas bloqueadas recibidas vía Socket.IO:', data);
          if (!data.reservas || !Array.isArray(data.reservas)) {
            // Si no tenemos datos completos de las reservas, recargar todo
            fetchData();
          }
        },
        onError: (error) => {
          console.error('Error en Socket.IO:', error);
          toast.error('Error en la comunicación en tiempo real');
        }
      });
    });

    // Limpieza al desmontar el componente
    return () => {
      // Desconectar y limpiar Socket.IO
      socketService.disconnect();
      // Limpiar listeners de Socket.IO
      useReservationsStore.getState().cleanupSocketListeners();
    };
  }, [fetchData, initSocketListeners]);

  const filteredUsers = useMemo(() => {
    return users.filter(
      user =>
        user.nombre.toLowerCase().includes(userSearch.toLowerCase()) ||
        user.email.toLowerCase().includes(userSearch.toLowerCase()) ||
        (user.id_personalizado &&
          user.id_personalizado
            .toLowerCase()
            .includes(userSearch.toLowerCase()))
    )
  }, [users, userSearch])

  const filteredReservations = useMemo(() => {
    return reservations.filter(
      reservation =>
        reservation.id.toString().includes(reservationSearch) ||
        (reservation.nombre_festejado &&
          reservation.nombre_festejado
            .toLowerCase()
            .includes(reservationSearch.toLowerCase()))
    )
  }, [reservations, reservationSearch])

  useEffect(() => {
    const checkScreenSize = () => {
      setIsSmallScreen(window.innerWidth < 768)
    }

    checkScreenSize()
    window.addEventListener('resize', checkScreenSize)

    return () => window.removeEventListener('resize', checkScreenSize)
  }, [])

  const handleViewReservation = useCallback(reservation => {
    setSelectedReservation(reservation)
    setIsReservationModalOpen(true)
  }, [])

  // Función para filtrar datos por mes
  const filterDataByMonth = useCallback(
    (data, dateField) => {
      // Primero verificar si data es un array
      if (!Array.isArray(data)) return [];
      
      // Filtrar por mes
      return data.filter(item => {
        // Verificar que el item y el campo de fecha existen
        if (!item || !item[dateField]) return false;
        
        // Convertir a objeto Date
        const itemDate = new Date(item[dateField]);
        
        // Asegurarse de que la fecha es válida
        if (isNaN(itemDate.getTime())) return false;
        
        // Comparar tanto mes como año
        return itemDate.getMonth() === selectedMonth && 
               itemDate.getFullYear() === selectedYear;
      });
    },
    [selectedMonth, selectedYear]
  );

  const handleAddItem = useCallback(() => {
    if (activeTab === 'payments') {
      setSelectedPayment(null)
      setPaymentModalMode('add')
      setIsPaymentModalOpen(true)
    } else {
      setEditingItem(null)
      setIsModalOpen(true)
    }
  }, [activeTab])

  const handleSavePayment = useCallback(async (paymentData) => {
    try {
      await usePaymentsStore.getState().addPayment(paymentData);
      setIsPaymentModalOpen(false);
      fetchData();
    } catch (error) {
      console.error('Error al crear el pago:', error);
      toast.error('Error al crear el pago');
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate, fetchData, setIsPaymentModalOpen])

  const handleEditItem = useCallback(
    item => {
      console.log('Editando elemento:', item)
      if (activeTab === 'payments') {
        setSelectedPayment(item)
        setPaymentModalMode('add')
        setIsPaymentModalOpen(true)
      } else {
        setEditingItem(item)
        setIsModalOpen(true)
      }
    },
    [activeTab]
  )
  
  const handleUpdatePaymentStatus = useCallback(async (paymentId, newStatus) => {
    try {
      await usePaymentsStore.getState().updatePaymentStatus(paymentId, newStatus);
      // Actualizar la UI con datos frescos
      await fetchData();
    } catch (error) {
      console.error('Error al actualizar el estado del pago:', error);
      toast.error('Error al actualizar el estado del pago');
      
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate, fetchData])

  const handleReservationStatusChange = useCallback(async (reservationId, newStatus) => {
    try {
      // Usar la tienda Zustand para actualizar el estado de la reserva
      await useReservationsStore.getState().updateReservationStatus(reservationId, newStatus);
      // No es necesario actualizar manualmente el estado local, ya que se actualizará
      // automáticamente desde la tienda al llamar a updateReservationStatus
      toast.success('Estado de la reserva actualizado con éxito');
    } catch (error) {
      console.error('Error al actualizar el estado de la reserva:', error);
      toast.error('Error al actualizar el estado de la reserva');
      
      if (error.response?.status === 401) {
        navigate('/signin');
      }
    }
  }, [navigate])

  const handleSendEmail = useCallback(reservation => {
    toast.info(`Funcionalidad de enviar correo a ${reservation.usuario.email}`)
  }, [])

  const handleContactUser = useCallback(reservation => {
    toast.info(
      `Funcionalidad de contactar al usuario ${reservation.usuario.nombre}`
    )
  }, [])

  const handleError = useCallback(
    (error, action) => {
      if (error.response) {
        if (error.response.status === 404) {
          toast.warning('El elemento ya no existe')
        } else if (error.response.status === 401) {
          toast.error(
            'Tu sesión ha expirado. Por favor, inicia sesión nuevamente.'
          )
          navigate('/signin')
        } else {
          toast.error(
            `Error del servidor al ${action} el elemento: ${
              error.response.data.message || 'Algo salió mal'
            }`
          )
        }
      } else if (error.request) {
        toast.error('No se recibió respuesta del servidor')
      } else {
        toast.error(`Error al ${action} el elemento`)
      }
      console.error(`Error al ${action} el elemento:`, error)
    },
    [navigate]
  )

  function removeCircularReferences (obj, seen = new WeakSet()) {
    if (typeof obj !== 'object' || obj === null) {
      return obj
    }
    if (seen.has(obj)) {
      return '[Circular]'
    }
    seen.add(obj)
    const newObj = Array.isArray(obj) ? [] : {}
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        newObj[key] = removeCircularReferences(obj[key], seen)
      }
    }
    return newObj
  }

  const handleSubmit = useCallback(
    async data => {
      setLoading(true)
      try {
        console.log('Datos recibidos en handleSubmit:', data)
        
        // Limpiar y validar los datos
        const cleanedData = removeCircularReferences(data)
        console.log('Datos limpios a enviar al servidor:', cleanedData)
        
        // Para reservas, validar y asegurar que id_usuario sea un número
        if (activeTab === 'reservations' && !cleanedData.id_usuario) {
          toast.error('Debe seleccionar un usuario para la reserva')
          setLoading(false)
          return
        }
        
        if (activeTab === 'reservations') {
          cleanedData.id_usuario = Number(cleanedData.id_usuario)
        }
        
        // Usar las tiendas Zustand para crear/actualizar
        let result;
        
        if (editingItem) {
          // Actualizar usando las tiendas Zustand
          switch (activeTab) {
            case 'users':
              result = await useUsersStore.getState().updateUser(editingItem.id, cleanedData);
              break;
            case 'reservations':
              result = await useReservationsStore.getState().updateReservation(editingItem.id, cleanedData);
              break;
            case 'finances':
              result = await useFinancesStore.getState().updateFinance(editingItem.id, cleanedData);
              break;
            case 'packages':
              result = await usePackagesStore.getState().updatePackage(editingItem.id, cleanedData);
              break;
            case 'extras':
              result = await useExtrasStore.getState().updateExtra(editingItem.id, cleanedData);
              break;
            case 'opcionesAlimento':
              result = await useFoodOptionsStore.getState().updateFoodOption(editingItem.id, cleanedData);
              break;
            case 'tematicas':
              result = await useThemesStore.getState().updateTheme(editingItem.id, cleanedData);
              break;
            case 'mamparas':
              result = await useMamparasStore.getState().updateMampara(editingItem.id, cleanedData);
              break;
            case 'payments':
              result = await usePaymentsStore.getState().updatePayment(editingItem.id, cleanedData);
              break;
            default:
              throw new Error('Tipo de formulario no reconocido');
          }
        } else {
          // Crear usando las tiendas Zustand
          switch (activeTab) {
            case 'users':
              result = await useUsersStore.getState().addUser(cleanedData);
              break;
            case 'reservations':
              result = await useReservationsStore.getState().addReservation(cleanedData);
              break;
            case 'finances':
              result = await useFinancesStore.getState().addFinance(cleanedData);
              break;
            case 'packages':
              result = await usePackagesStore.getState().addPackage(cleanedData);
              break;
            case 'extras':
              result = await useExtrasStore.getState().addExtra(cleanedData);
              break;
            case 'opcionesAlimento':
              result = await useFoodOptionsStore.getState().addFoodOption(cleanedData);
              break;
            case 'tematicas':
              result = await useThemesStore.getState().addTheme(cleanedData);
              break;
            case 'mamparas':
              result = await useMamparasStore.getState().addMampara(cleanedData);
              break;
            case 'payments':
              result = await usePaymentsStore.getState().addPayment(cleanedData);
              break;
            default:
              throw new Error('Tipo de formulario no reconocido');
          }
        }
        
        setIsModalOpen(false);
        // Actualizar la UI con datos frescos
        await fetchData();
        
      } catch (error) {
        console.error('Error en handleSubmit:', error)
        if (error.response && error.response.status === 401) {
          toast.error(
            'Tu sesión ha expirado. Por favor, inicia sesión nuevamente.'
          )
          navigate('/signin')
          return
        } else {
          handleError(error, editingItem ? 'actualizar' : 'crear')
        }
      } finally {
        setLoading(false)
      }
    },
    [activeTab, editingItem, fetchData, handleError, navigate, setLoading, setIsModalOpen]
  )

  const handleDeleteItem = async (endpoint, id, successMessage) => {
    const result = await Swal.fire({
      title: '¿Estás seguro?',
      text: 'Esta acción desactivará el registro. Podrás reactivarlo más tarde si es necesario.',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#3085d6',
      cancelButtonColor: '#d33',
      confirmButtonText: 'Sí, desactivar',
      cancelButtonText: 'Cancelar'
    })

    if (result.isConfirmed) {
      try {
        // Determinar qué tienda usar basado en el endpoint
        switch (endpoint) {
          case '/api/usuarios':
            await useUsersStore.getState().deleteUser(id);
            break;
          case '/api/reservas':
            await useReservationsStore.getState().deleteReservation(id);
            break;
          case '/api/finanzas':
            await useFinancesStore.getState().deleteFinance(id);
            break;
          case '/api/paquetes':
            await usePackagesStore.getState().deletePackage(id);
            break;
          case '/api/extras':
            await useExtrasStore.getState().deleteExtra(id);
            break;
          case '/api/opciones-alimentos':
            await useFoodOptionsStore.getState().deleteFoodOption(id);
            break;
          case '/api/tematicas':
            await useThemesStore.getState().deleteTheme(id);
            break;
          case '/api/mamparas':
            await useMamparasStore.getState().deleteMampara(id);
            break;
          case '/api/pagos':
            await usePaymentsStore.getState().deletePayment(id);
            break;
          default:
            // Si no hay una tienda específica para el endpoint, usar axios directamente
            await axiosInstance.delete(`${endpoint}/${id}`);
        }
        
        Swal.fire('¡Desactivado!', successMessage, 'success');
        // Actualizar la UI con datos frescos
        await fetchData();
      } catch (error) {
        handleError(error, 'desactivar');
      }
    }
  }

  // Eliminada la función local generateRandomPassword ya que la estamos importando desde useUiStore

  const handleDownloadFile = useCallback(async (id, type) => {
    try {
      // Usar la tienda Zustand para descargar el archivo
      const blob = await useFinancesStore.getState().downloadFinanceFile(id, type);
      
      // Crear URL para el blob y descargar el archivo
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `finanza_${id}_${type}.pdf`);
      document.body.appendChild(link);
      link.click();
      link.parentNode.removeChild(link);
      
      // Liberar la URL
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error al descargar el archivo:', error);
      toast.error('Error al descargar el archivo');
    }
  }, [])

  const handleViewDetails = useCallback(finance => {
    setSelectedFinance(finance)
  }, [])

  const handleAddCategory = useCallback(async newCategory => {
    try {
      await useCategoriesStore.getState().addCategory({
        nombre: newCategory.nombre,
        color: newCategory.color || '#000000'
      });
      // Actualizar categorías tras la adición
      const updatedCategories = await fetchCategoriesZustand();
      setCategories(updatedCategories);
      toast.success('Categoría añadida con éxito');
    } catch (error) {
      console.error('Error al añadir la categoría:', error);
      toast.error('Error al añadir la categoría');
    }
  }, [fetchCategoriesZustand])

  const renderModalContent = useCallback(() => {
    const props = {
      editingItem,
      onSave: handleSubmit,
      generateRandomPassword,
      generatedPassword,
      users,
      packages,
      categories,
      onAddCategory: handleAddCategory,
      reservations,
      tematicas,
      foodOptions,
      extras,
      currentUser
    }
    switch (activeTab) {
      case 'users':
        return <UserForm {...props} />
      case 'reservations':
        return <ReservationForm {...props} />
      case 'finances':
        return <FinanceForm {...props} />
      case 'packages':
        return <PackageForm {...props} />
      case 'extras':
        return <ExtraForm {...props} />
      case 'opcionesAlimento':
        return <OpcionAlimentoForm {...props} />
      case 'tematicas':
        return <TematicaForm {...props} />
      case 'mamparas':
        return <MamparaForm {...props} />
      case 'payments':
        return <PaymentForm {...props} />
      default:
        return null
    }
  }, [
    activeTab,
    editingItem,
    handleSubmit,
    generateRandomPassword,
    generatedPassword,
    users,
    packages,
    categories,
    handleAddCategory,
    reservations,
    tematicas,
    foodOptions,
    extras
  ])

  return (
    <div className='min-h-screen bg-gradient-to-br from-blue-100 to-purple-100 p-8'>
      {isSmallScreen && showAlert && (
        <ScreenSizeAlert setShowAlert={setShowAlert} />
      )}
      <h1 className='text-4xl font-bold mb-8 text-center text-indigo-800'>
        Panel de Control
      </h1>
      <div className='grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-8'>
        <ReservationCalendar
          reservations={reservations}
          onSelectReservation={handleSelectReservation}
        />
        <UserSummary users={users} />
        <ReservationSummary
          reservations={reservations}
          filterDataByMonth={filterDataByMonth}
        />
        <FinancialSummary
          finances={finances}
          filterDataByMonth={filterDataByMonth}
          categories={categories}
        />
      </div>
      <div className='bg-white rounded-lg shadow-lg p-6'>
        <TabNavigation
          activeTab={activeTab}
          setActiveTab={setActiveTab}
          handleAddItem={handleAddItem}
        />
        {activeTab === 'users' && (
          <UserTable
            users={filteredUsers}
            userSearch={userSearch}
            setUserSearch={setUserSearch}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/usuarios',
                id,
                'Usuario desactivado con éxito',
                () => setIsModalOpen(false)
              )
            }
            handleViewUser={handleViewUser}
          />
        )}
        {activeTab === 'reservations' && (
          <ReservationTable
            reservations={filterDataByMonth(reservations, 'fecha_reserva')}
            reservationSearch={reservationSearch}
            setReservationSearch={setReservationSearch}
            handleViewReservation={handleViewReservation}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/reservas',
                id,
                'Reserva desactivada con éxito'
              )
            }
            selectedMonth={selectedMonth}
          />
        )}
        {activeTab === 'finances' && (
          <FinanceTable
            finances={filterDataByMonth(finances, 'fecha')}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/finanzas',
                id,
                'Finanza desactivada con éxito',
                () => setIsModalOpen(false)
              )
            }
            handleDownloadFile={handleDownloadFile}
            handleViewDetails={handleViewDetails}
            categories={categories}
            generateMonthlyReport={generateMonthlyReport}
          />
        )}
        {activeTab === 'packages' && (
          <PackageTable
            packages={packages}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/paquetes',
                id,
                'Paquete desactivado con éxito',
                () => setIsModalOpen(false),
                'paquetes'
              )
            }
          />
        )}
        {activeTab === 'extras' && (
          <ExtraTable
            extras={extras}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem('/api/extras', id, 'Extra eliminado con éxito')
            }
          />
        )}
        {activeTab === 'opcionesAlimento' && (
          <OpcionAlimentoTable
            opcionesAlimento={foodOptions}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/opciones-alimentos',
                id,
                'Opción de alimento eliminada con éxito'
              )
            }
          />
        )}
        {activeTab === 'tematicas' && (
          <TematicaTable
            tematicas={tematicas}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/tematicas',
                id,
                'Temática eliminada con éxito'
              )
            }
          />
        )}
        {activeTab === 'mamparas' && (
          <MamparaTable
            tematicas={tematicas}
            mamparas={mamparas}
            handleEditItem={handleEditItem}
            handleDeleteItem={id =>
              handleDeleteItem(
                '/api/mamparas',
                id,
                'Mampara eliminada con éxito'
              )
            }
          />
        )}
        {activeTab === 'payments' && (
          <PaymentTable
            payments={payments}
            reservations={reservations}
            onViewPayment={(payment) => {
              setSelectedPayment(payment)
              setPaymentModalMode('view')
              setIsPaymentModalOpen(true)
            }}
            onEditPayment={(payment) => {
              setSelectedPayment(payment)
              setPaymentModalMode('edit')
              setIsPaymentModalOpen(true)
            }}
          />
        )}
        {activeTab === 'auditoria' && (
          <AuditHistory />
        )}
        {activeTab === 'archived' && (
          <ArchivedTable
            items={archivedItems}
            itemSearch={archivedSearch}
            setItemSearch={setArchivedSearch}
            fetchData={fetchData}
            selectedMonth={selectedMonth}
            type="reservas"
          />
        )}
        {activeTab === 'galeria' && (
          <GaleriaManagement />
        )}
      </div>
      <MonthSelector
        selectedMonth={selectedMonth}
        setSelectedMonth={setSelectedMonth}
        selectedYear={selectedYear}
        setSelectedYear={setSelectedYear}
      />
      {isReservationModalOpen && selectedReservation && (
        <ReservationModal
          reservation={selectedReservation}
          onClose={handleCloseReservationModal}
          onStatusChange={newStatus =>
            handleReservationStatusChange(selectedReservation.id, newStatus)
          }
          onSendEmail={handleSendEmail}
          onContactUser={handleContactUser}
          tematicas={tematicas}
          extras={extras}
        />
      )}
      {isModalOpen && (
        <ItemModal
          isOpen={isModalOpen}
          onClose={() => setIsModalOpen(false)}
          title={`${editingItem ? 'Editar' : 'Agregar'} ${activeTab.slice(
            0,
            -1
          )}`}
          loading={loading}
          activeTab={activeTab}
          handleSubmit={handleSubmit}
          editingItem={editingItem}
          generatedPassword={generatedPassword}
          generateRandomPassword={generateRandomPassword}
          users={users}
          packages={packages}
          reservations={reservations}
          categories={categories}
          onAddCategory={handleAddCategory}
          tematicas={tematicas}
          foodOptions={foodOptions}
          extras={extras}
          mamparas={mamparas}
          currentUser={currentUser}
        />
      )}
      {selectedFinance && (
        <FinanceDetailModal
          finance={selectedFinance}
          onClose={() => setSelectedFinance(null)}
          onDownloadFile={handleDownloadFile}
        />
      )}
      {isPaymentModalOpen && (
        <PaymentModal
          payment={selectedPayment}
          isOpen={isPaymentModalOpen}
          onClose={() => {
            setSelectedPayment(null)
            setIsPaymentModalOpen(false)
          }}
          onUpdateStatus={handleUpdatePaymentStatus}
          onSavePayment={handleSavePayment}
          reservations={reservations}
          mode={paymentModalMode}
        />
      )}
      {isUserModalOpen && selectedUser && (
        <UserModal
          user={selectedUser}
          reservations={reservations.filter(res => res.id_usuario === selectedUser.id)}
          onClose={() => {
            setSelectedUser(null)
            setIsUserModalOpen(false)
          }}
          onEdit={handleEditItem}
          onSendEmail={() => toast.info(`Funcionalidad de enviar correo a ${selectedUser.email}`)}
        />
      )}
      {isReportModalOpen && (
        <MonthlyReportModal
          isOpen={isReportModalOpen}
          onClose={() => setIsReportModalOpen(false)}
          finances={finances}
          categories={categories}
          selectedMonth={selectedMonth}
          selectedYear={selectedYear}
        />
      )}
    </div>
  )
}

export default Dashboardimport { io } from 'socket.io-client';

let socket;

/**
 * Inicializa la conexión Socket.IO con el servidor
 * @param {string} serverUrl - URL del servidor al que conectarse (opcional, usa la URL base de la aplicación por defecto)
 * @returns {Object} El objeto socket para su uso en otros componentes
 */
export const initSocket = (serverUrl = '') => {
  // Si ya existe una conexión, no crear una nueva
  if (socket) return socket;

  // Determinar la URL del servidor
  const url = serverUrl || import.meta.env.VITE_API_URL || window.location.origin.replace(/:\d+$/, ':3001');

  // Crear y configurar la conexión Socket.IO
  socket = io(url, {
    transports: ['websocket', 'polling'],
    withCredentials: true,
    autoConnect: true,
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionAttempts: 10
  });

  // Configurar manejadores de eventos por defecto
  socket.on('connect', () => {
    console.log('Conectado a Socket.IO, ID:', socket.id);
  });

  socket.on('connect_error', (error) => {
    console.error('Error de conexión Socket.IO:', error);
  });

  socket.on('disconnect', (reason) => {
    console.log('Desconectado de Socket.IO:', reason);
  });

  return socket;
};

/**
 * Suscribe a un evento Socket.IO
 * @param {string} event - Nombre del evento
 * @param {Function} callback - Función a ejecutar cuando se reciba el evento
 */
export const subscribe = (event, callback) => {
  if (!socket) {
    console.warn('Socket.IO no inicializado. Llamar a initSocket() primero.');
    return;
  }
  socket.on(event, callback);
};

/**
 * Cancela la suscripción a un evento Socket.IO
 * @param {string} event - Nombre del evento
 * @param {Function} callback - Función que fue registrada (opcional, si se omite se eliminan todos los handlers)
 */
export const unsubscribe = (event, callback) => {
  if (!socket) {
    console.warn('Socket.IO no inicializado. Llamar a initSocket() primero.');
    return;
  }
  
  if (callback) {
    socket.off(event, callback);
  } else {
    socket.off(event);
  }
};

/**
 * Cierra la conexión Socket.IO
 */
export const disconnect = () => {
  if (!socket) return;
  
  socket.disconnect();
  socket = null;
};

/**
 * Obtiene el objeto socket para uso directo
 * @returns {Object|null} El objeto socket o null si no está inicializado
 */
export const getSocket = () => socket;

/**
 * Emite un evento al servidor
 * @param {string} event - Nombre del evento
 * @param {any} data - Datos a enviar con el evento
 */
export const emit = (event, data) => {
  if (!socket) {
    console.warn('Socket.IO no inicializado. Llamar a initSocket() primero.');
    return;
  }
  socket.emit(event, data);
};

export default {
  initSocket,
  subscribe,
  unsubscribe,
  disconnect,
  getSocket,
  emit
};// Exportaciones de todas las tiendas Zustand
import useUiStore from './uiStore'
import useUsersStore from './usersStore'
import useReservationsStore from './reservationsStore'
import useFinancesStore from './financesStore'
import usePackagesStore from './packagesStore'
import useCategoriesStore from './categoriesStore'
import useThemesStore from './themesStore'
import useExtrasStore from './extrasStore'
import useFoodOptionsStore from './foodOptionsStore'
import useMamparasStore from './mamparasStore'
import usePaymentsStore from './paymentsStore'

// Exportar todas las tiendas
export {
  useUiStore,
  useUsersStore,
  useReservationsStore,
  useFinancesStore,
  usePackagesStore,
  useCategoriesStore,
  useThemesStore,
  useExtrasStore,
  useFoodOptionsStore,
  useMamparasStore,
  usePaymentsStore
}import { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { jwtDecode } from 'jwt-decode';
import axiosInstance from '../components/axiosConfig';
import { toast } from 'react-toastify';

const AuthContext = createContext(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth debe ser usado dentro de un AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userType, setUserType] = useState(null);
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const checkAuth = useCallback(async () => {
    const token = localStorage.getItem('token');
    if (!token) {
      setIsAuthenticated(false);
      setUserType(null);
      setUser(null);
      setLoading(false);
      return false;
    }

    try {
      const decoded = jwtDecode(token);
      if (decoded.exp * 1000 > Date.now()) {
        setIsAuthenticated(true);
        setUserType(decoded.userType);
        setUser({
          id: decoded.id,
          nombre: decoded.nombre,
          email: decoded.email,
          tipo_usuario: decoded.userType
        });

        axiosInstance.defaults.headers.common['Authorization'] = `Bearer ${token}`;

        try {
          const response = await axiosInstance.get('/usuarios/me');
          setUser(response.data);
        } catch (error) {
          console.error('Error al obtener datos del usuario:', error);
        }

        setLoading(false);
        return true;
      } else {
        throw new Error('Token expirado');
      }
    } catch (error) {
      console.error('Error al verificar autenticación:', error);
      localStorage.removeItem('token');
      delete axiosInstance.defaults.headers.common['Authorization'];
      setIsAuthenticated(false);
      setUserType(null);
      setUser(null);
      setLoading(false);
      return false;
    }
  }, []);

  const login = useCallback(async (emailOrToken, passwordOrUserData) => {
    let token, userData;

    // Caso 1: Login con email/password
    if (typeof passwordOrUserData === 'string' || passwordOrUserData === undefined) {
      try {
        const response = await axiosInstance.post('/auth/login', {
          email: emailOrToken,
          password: passwordOrUserData
        });
        token = response.data.token;
        userData = null; // Se obtendrá del token o del endpoint /me
      } catch (error) {
        console.error('Error en inicio de sesión:', error);
        throw error; // Propagar el error para que InventoryLoginModal pueda manejarlo
      }
    } 
    // Caso 2: Login directo con token
    else {
      token = emailOrToken;
      userData = passwordOrUserData;
    }

    // Guardar token en localStorage (fuente principal) y también en cookies para compatibilidad
    localStorage.setItem('token', token);
    axiosInstance.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    
    const decoded = jwtDecode(token);
    setIsAuthenticated(true);
    setUserType(decoded.userType);
    
    if (userData) {
      setUser(userData);
    } else {
      setUser({
        id: decoded.id,
        nombre: decoded.nombre || decoded.name,
        email: decoded.email,
        tipo_usuario: decoded.userType
      });
      
      // Obtener datos de usuario completos
      try {
        const response = await axiosInstance.get('/usuarios/me');
        setUser(response.data);
      } catch (error) {
        console.error('Error al obtener datos del usuario:', error);
      }
    }

    window.dispatchEvent(new Event('auth-change'));
  }, []);

  const logout = useCallback(async () => {
    try {
      await axiosInstance.post('/auth/logout');
    } catch (error) {
      console.error('Error en logout:', error);
    } finally {
      localStorage.removeItem('token');
      delete axiosInstance.defaults.headers.common['Authorization'];
      setIsAuthenticated(false);
      setUserType(null);
      setUser(null);
      window.dispatchEvent(new Event('auth-change'));
    }
  }, []);

  useEffect(() => {
    checkAuth();

    const handleStorageChange = (e) => {
      if (e.key === 'token') {
        checkAuth();
      }
    };

    window.addEventListener('storage', handleStorageChange);
    
    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [checkAuth]);

  const value = {
    isAuthenticated,
    userType,
    user,
    login,
    logout,
    loading,
    checkAuth
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};import { Navigate, Outlet } from 'react-router-dom';
import {jwtDecode} from 'jwt-decode';
import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { toast, ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import { FiCheck, FiX, FiLoader, FiShield } from 'react-icons/fi';

// Componente FinalIcon: Animación de éxito/error con diseño minimalista
const FinalIcon = ({ success }) => (
  <div className="min-h-screen w-full bg-gradient-to-br from-indigo-50 to-purple-50 flex flex-col items-center justify-center p-4 relative overflow-hidden">
    {/* Elementos decorativos - formas geométricas sutiles */}
    <div className="absolute top-0 right-0 w-64 h-64 bg-indigo-100 rounded-full -mr-32 -mt-32 opacity-70"></div>
    <div className="absolute bottom-0 left-0 w-80 h-80 bg-purple-100 rounded-full -ml-40 -mb-40 opacity-70"></div>
    <div className="absolute top-1/3 left-1/4 w-12 h-12 bg-indigo-200 rounded-full transform rotate-45 opacity-60"></div>
    <div className="absolute bottom-1/4 right-1/3 w-20 h-20 bg-purple-200 rounded-full transform rotate-12 opacity-60"></div>
    
    <motion.div
      initial={{ opacity: 0, scale: 0.9 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.9 }}
      transition={{ type: "spring", stiffness: 300, damping: 20 }}
      className="relative z-10"
    >
      <div className="relative mb-6">
        {/* Círculo pulsante exterior */}
        <motion.div 
          className={`absolute inset-0 rounded-full ${success ? 'bg-green-100' : 'bg-red-100'}`}
          animate={{ 
            scale: [1, 1.2, 1],
            opacity: [0.7, 0.5, 0.7] 
          }}
          transition={{ 
            duration: 2, 
            repeat: Infinity,
            ease: "easeInOut"
          }}
        />
        
        {/* Círculo con icono */}
        <div className="relative w-20 h-20 bg-white rounded-full shadow-md flex items-center justify-center z-10">
          <motion.div
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            transition={{ 
              type: "spring",
              stiffness: 300,
              damping: 20
            }}
            className={success ? "text-green-500" : "text-red-500"}
          >
            {success ? <FiCheck size={32} /> : <FiX size={32} />}
          </motion.div>
        </div>
      </div>
      
      <motion.h3
        className="text-xl font-semibold text-gray-800 mb-2 text-center"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: 0.2 }}
      >
        {success ? "¡Acceso verificado!" : "Acceso denegado"}
      </motion.h3>
      
      <motion.div 
        className="flex space-x-1 items-center justify-center text-gray-500"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: 0.3 }}
      >
        <span>{success ? "Redirigiendo" : "Redirigiendo a inicio de sesión"}</span>
        <motion.span
          animate={{ x: [0, 10] }}
          transition={{ 
            duration: 0.8, 
            repeat: Infinity,
            repeatType: "loop"
          }}
        >→</motion.span>
      </motion.div>
    </motion.div>
  </div>
);

const ProtectedRoute = ({ redirectPath = '/signin', allowedRoles = [], children }) => {
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isAllowed, setIsAllowed] = useState(false);
  const [showFinalIcon, setShowFinalIcon] = useState(false);
  const hasNotified = useRef(false);

  useEffect(() => {
    const verifyToken = async () => {
      const hasValidated = sessionStorage.getItem('hasValidated');

      try {
        const token = localStorage.getItem('token');

        if (!token) {
          setIsAuthenticated(false);
          setIsAllowed(false);
          throw new Error('No token found');
        }

        const decoded = jwtDecode(token);
        if (!decoded || decoded.exp <= Date.now() / 1000) {
          localStorage.removeItem('token');
          setIsAuthenticated(false);
          throw new Error('Invalid or expired token');
        }

        setIsAuthenticated(true);
        const hasPermission = allowedRoles.includes(decoded.userType || decoded.role);
        setIsAllowed(hasPermission);

        setShowFinalIcon(!hasValidated);

      } catch (error) {
        console.error('Authentication error:', error);
        setShowFinalIcon(true);
      } finally {
        // Simulamos un pequeño retardo para que se aprecie la animación
        await new Promise((r) => setTimeout(r, 400));
        setIsLoading(false);

        if (isAllowed) {
          sessionStorage.setItem('hasValidated', 'true');
        }
      }
    };

    verifyToken();
  }, [allowedRoles]);

  useEffect(() => {
    if (!isLoading && !isAllowed && !hasNotified.current) {
      const message = isAuthenticated
        ? 'No tienes permisos suficientes'
        : 'Por favor inicia sesión';

      toast.error(message, {
        position: 'top-center',
        autoClose: 3000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnHover: true,
        draggable: true,
        className: '!bg-white/10 backdrop-blur-lg border border-white/20',
      });

      hasNotified.current = true;
    }
  }, [isLoading, isAllowed, isAuthenticated]);

  // Componente LoadingAnimation: Preloader minimalista y moderno
  const LoadingAnimation = () => (
    <div className="min-h-screen w-full bg-gradient-to-br from-indigo-50 to-purple-50 flex flex-col items-center justify-center p-4 relative overflow-hidden">
      {/* Elementos decorativos - formas geométricas sutiles */}
      <div className="absolute top-0 right-0 w-64 h-64 bg-indigo-100 rounded-full -mr-32 -mt-32 opacity-70"></div>
      <div className="absolute bottom-0 left-0 w-80 h-80 bg-purple-100 rounded-full -ml-40 -mb-40 opacity-70"></div>
      <div className="absolute top-1/3 left-1/4 w-12 h-12 bg-indigo-200 rounded-full transform rotate-45 opacity-60"></div>
      <div className="absolute bottom-1/4 right-1/3 w-20 h-20 bg-purple-200 rounded-full transform rotate-12 opacity-60"></div>
      
      <motion.div
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.9 }}
        transition={{ duration: 0.4 }}
        className="relative z-10 flex flex-col items-center text-center"
      >
        <div className="relative mb-6">
          {/* Círculo pulsante exterior */}
          <motion.div 
            className="absolute inset-0 rounded-full bg-indigo-100"
            animate={{ 
              scale: [1, 1.2, 1],
              opacity: [0.7, 0.5, 0.7] 
            }}
            transition={{ 
              duration: 2, 
              repeat: Infinity,
              ease: "easeInOut"
            }}
          />
          
          {/* Anillo giratorio */}
          <motion.div
            className="absolute inset-0 rounded-full border-4 border-indigo-300 border-t-indigo-500"
            style={{ borderRightColor: 'transparent', borderBottomColor: 'transparent', borderLeftColor: 'transparent' }}
            animate={{ rotate: 360 }}
            transition={{ 
              duration: 1.5,
              repeat: Infinity,
              ease: "linear"
            }}
          />
          
          {/* Círculo con icono */}
          <div className="relative w-20 h-20 bg-white rounded-full shadow-md flex items-center justify-center z-10">
            <FiShield className="text-indigo-500" size={24} />
          </div>
        </div>
        
        <motion.h3
          className="text-xl font-semibold text-gray-800 mb-2"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.2 }}
        >
          Verificando permisos
        </motion.h3>
        
        <motion.div 
          className="flex space-x-1 items-center text-gray-500"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.3 }}
        >
          <span>Un momento por favor</span>
          <motion.span
            animate={{ opacity: [0, 1, 0] }}
            transition={{ 
              duration: 1.5, 
              repeat: Infinity,
              repeatType: "loop"
            }}
          >...</motion.span>
        </motion.div>
        
        {/* Barra de progreso */}
        <motion.div
          className="w-60 h-1 bg-gray-200 rounded-full mt-6 overflow-hidden"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.4 }}
        >
          <motion.div
            className="h-full bg-indigo-500"
            animate={{ 
              width: ['0%', '100%'],
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              ease: "easeInOut",
            }}
          />
        </motion.div>
      </motion.div>
    </div>
  );

  // Lógica de renderizado
  if (isLoading) {
    return (
      <>
        <LoadingAnimation />
        <ToastContainer />
      </>
    );
  }

  if (showFinalIcon) {
    return (
      <AnimatePresence mode="wait">
        <motion.div key="final-icon">
          <FinalIcon success={isAllowed} />
          {setTimeout(() => {
            setShowFinalIcon(false);
            if (isAllowed) {
              return;
            } else {
              if (isAuthenticated) {
                window.location.replace('/reservations');
              } else {
                window.location.replace(redirectPath);
              }
            }
          }, 800)}
          <ToastContainer />
        </motion.div>
      </AnimatePresence>
    );
  }

  if (isAllowed) {
    return (
      <motion.div
        key="protected-content"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.3 }}
      >
        {children ? children : <Outlet />}
        <ToastContainer />
      </motion.div>
    );
  }

  return null;
};

export default ProtectedRoute;import axios from 'axios';
import { toast } from 'react-toastify';

// Determinar la URL base correcta para evitar duplicar /api
const determineBaseURL = () => {
  const apiUrl = import.meta.env.VITE_API_URL;
  // Si ya tenemos una URL de API y termina con /api, usarla directamente
  if (apiUrl) {
    return apiUrl;
  }
  // Si no hay una URL de API configurada, usar /api como valor por defecto
  return '/api';
};

// Exportar como exportación con nombre para ser importado con { axiosInstance }
export const axiosInstance = axios.create({
  baseURL: determineBaseURL(),
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
    'Cache-Control': 'no-cache',
    'Pragma': 'no-cache',
    'Expires': '0'
  }
});

// Request Interceptor
axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }

    // Log request details in development
    if (import.meta.env.MODE === 'development') {
      console.log('Request:', {
        url: config.url,
        method: config.method,
        data: config.data,
        headers: config.headers
      });
    }

    return config;
  },
  (error) => {
    console.error('Request Interceptor Error:', error);
    return Promise.reject(error);
  }
);

// Response Interceptor
axiosInstance.interceptors.response.use(
  (response) => {
    // Log response in development
    if (import.meta.env.MODE === 'development') {
      console.log('Response:', {
        status: response.status,
        data: response.data,
        headers: response.headers
      });
    }
    return response;
  },
  (error) => {
    console.error('Response Error:', error);

    // Handle network errors
    if (!error.response) {
      toast.error('Error de conexión. Por favor, verifica tu conexión a internet.');
      return Promise.reject(error);
    }

    // Handle different error status codes
    switch (error.response.status) {
      case 400:
        toast.error(error.response.data.message || 'Solicitud inválida');
        break;
      case 401:
        const token = localStorage.getItem('token');
        // Evitar redirección si estamos en la página de login
        const isLoginPage = window.location.pathname === '/signin';
        if (token && !isLoginPage) {
          localStorage.removeItem('token');
          toast.error('Tu sesión ha expirado. Por favor, inicia sesión nuevamente.');
          window.location.href = '/signin';
        }
        break;
      case 403:
        toast.error('No tienes permiso para realizar esta acción');
        break;
      case 404:
        toast.error('Recurso no encontrado');
        break;
      case 409:
        toast.error('El horario seleccionado ya no está disponible');
        break;
      case 422:
        const validationErrors = error.response.data.errors;
        if (validationErrors) {
          Object.values(validationErrors).forEach(error => {
            toast.error(error);
          });
        } else {
          toast.error('Error de validación en los datos');
        }
        break;
      case 500:
        toast.error('Error del servidor. Por favor, intenta más tarde');
        break;
      default:
        toast.error('Ocurrió un error inesperado');
    }

    return Promise.reject(error);
  }
);

export default axiosInstance;